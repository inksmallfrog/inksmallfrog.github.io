{"meta":{"title":"墨小蛙","subtitle":null,"description":"请让我带你到这个小镇愿望实现的地方吧~","author":"墨小蛙","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-12-25T08:11:46.979Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-12-25T08:11:46.981Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-12-25T08:11:46.981Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-12-25T08:11:46.982Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-12-25T08:11:46.983Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-01-14T03:17:24.883Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-12-26T07:47:34.167Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-12-25T08:11:46.987Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"bangumi","date":"2019-12-26T13:32:48.000Z","updated":"2019-12-26T07:17:15.344Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-12-25T08:11:46.988Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-12-25T08:11:46.989Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-12-25T08:11:46.990Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"Web移动端适配之映射关系与视口","slug":"Web移动端适配之映射关系与视口","date":"2017-04-17T01:45:11.000Z","updated":"2020-01-14T02:33:04.024Z","comments":true,"path":"2017/04/17/Web移动端适配之映射关系与视口/","link":"","permalink":"/2017/04/17/Web移动端适配之映射关系与视口/","excerpt":"上一篇讨论移动端适配的时候列出了一些结论，在这里回顾一下其中最重要的几个也就是今天要讨论的几项内容： 在移动端下，设备厂商&amp;浏览器厂商会为网页选定一个default_html_width作为默认html.width，并以此为基础建立“初始缩放”映射关系:default_html_width =&gt; device_width html元素宽度的改变的根本原因在于html宽度的改变 移动端用户缩放时不会改变html.width，只会修改映射关系。 不过在我们谈“初始缩放”之前，我们还是要回顾一下Web中涉及的所有映射关系。","text":"上一篇讨论移动端适配的时候列出了一些结论，在这里回顾一下其中最重要的几个也就是今天要讨论的几项内容： 在移动端下，设备厂商&amp;浏览器厂商会为网页选定一个default_html_width作为默认html.width，并以此为基础建立“初始缩放”映射关系:default_html_width =&gt; device_width html元素宽度的改变的根本原因在于html宽度的改变 移动端用户缩放时不会改变html.width，只会修改映射关系。 不过在我们谈“初始缩放”之前，我们还是要回顾一下Web中涉及的所有映射关系。 映射关系我们这篇文章还是只讨论横向方向的映射。 记映射关系 a =&gt; b = 1 : x 代表a上每1个像素在b上显示为x个像素 PC端 程序员为在CSS(绝对的或相对的)编写宽度信息 浏览器加载html，设置html.width=browser.width，设置映射关系html.width=&gt;browser.width = 1:1，并计算html下的所有元素CSS属性 当浏览器窗口大小改变时，重新设置html.width为browser.width，并计算html下的所有元素CSS属性 当用户进行缩放时，重新设置html.width=browser.width / scaleRatio，设置映射关系html.width=&gt;browser.width=1:scaleRatio，并计算html下的所有元素CSS属性 涉及到的映射关系： 未缩放时html =&gt; browser = 1 : 1 缩放时html =&gt; browser = 1 : scaleRatio 移动端browser.width === device.width 恒成立 程序员为html中的各元素编写CSS(绝对的或相对的) 浏览器加载html，设置html.width为default_html_width，设置映射关系html.width=&gt;browser.width = 1 : device.width / default_html_width，并计算html下的所有元素CSS属性 当用户进行缩放时，设置映射关系(html.width / scaleRatio) =&gt; browser.width = 1 : device.width * scaleRatio / default_html_width 涉及到的映射关系： 未缩放时html =&gt; browser = html.width=&gt;browser.width = 1 : device.width / default_html_width 缩放时html =&gt; browser = 1 : device.width * scaleRatio / default_html_width 总结映射关系： PC端：未缩放时html =&gt; browser = 1 : 1缩放时html =&gt; browser = 1 : scaleRatio移动端：未缩放时html =&gt; browser = 1 : device.width / default_html_width缩放时html =&gt; browser = 1 : device.width * scaleRatio / default_html_width 上面的结论里，device.width是一个固定值，你的设备宽度不太可能忽大忽小，而default_html_width默认情况下，是由设备厂商&amp;浏览器厂商给定的某个固定值。 所以默认情况下device.width / default_html_width就是一个常数，我们先把它称作default-initial-scale。 那这么看来，default-initial-scale = 1的情况不就和PC端一样了么？是的，映射关系是一样的。但是如果我们改一下，把所有变量都列出来，就有区别了 PC端：未缩放时html =&gt; browser = html.width : html.width缩放时html =&gt; browser = html.width : scaleRatio * html.width移动端：未缩放时html =&gt; browser = 1 : default-initial-scale缩放时html =&gt; browser = 1 : scaleRatio * default-initial-scale PC端改变html大小的方法很多，但在移动端，缩放不会改变html大小，甚至大部分移动设备旋转屏幕也不会，（凡事都有例外，当屏幕旋转后超出default_html_width的时候会改变html的大小，因为这时候就相当于是PC端了（比如iPad））所以可以把它当做常量看。 不过当default-initial-scale=1的时候，确实会有很多帮助，但之前也说了，大部分设备中浏览器的default-initial-scale都不是1，所以设置这个“初始缩放”值就是整个移动端适配的核心。 initial-scale它是计算谁的？不过你可能还没想清楚，把initial-scale设为1到底有什么好处。当然就相当于页面不会发生映射。如果你和我刚接触这个概念时的想法一样，那你可能会想问这么做岂不是很糟糕？如果不发生映射，一个980px的html在320px的屏幕上就会被分成3份多20px……那么用户就不得不使用讨厌的横向滚动条来查看页面的特定位置。 但是，这种理解方式的前提是，你认为default_html_width是不会发生改变的。但我们在上一篇讨论中说过，这个值只是厂商们选出的一个合适的默认值。嗯，默认的意思就是，如果你希望它改变，它还是可以变化的。 所以说这个initial-scale，是在device.width固定的情况下，用来自己定义html_width的。 所以你把initial-scale设为1，就是说你希望你的html_width和device.width一样大，这样的话你在CSS中定义的16px的文字，不管在怎样的设备中都实实在在的是16px，再也不会像上一篇中被映射成了蚂蚁大的5px。 可是请等等，这里还有一个很严重的问题可是请等等，这里还有一个很严重的问题……我们在上一篇讨论过，实际的像素是多大其实没什么意义，用户更在意物理上的距离，也就是用cm度量的那种距离……到底有多长？ 我还是取来上一次说的设备A和B A设备：物理尺寸：10cm * 20cm像素： 320cm * 640cm像素密度： 32px/cm B设备：物理尺寸：10cm * 20cm像素： 640cm * 1280cm像素密度： 64px/cm 如果按照上面的计算规则，在我们把initial-scale都设为1的情况下，对于一个16px的文字 A设备：映射关系： 320 =&gt; 320实际像素： x / 16 = 320 / 320 =&gt; x = 16px实际长度： l = 16px / 32(px/cm) = 0.5cm B设备：映射关系： 640 =&gt; 640实际像素： x / 16 = 640 / 640 =&gt; x = 16px实际长度： l = 16 / 64 = 0.25cm 这下问题就严重了，同样10cm宽的设备上，为了保证initial-scale为1结果产生了差异。那我们是不是应该针对B设备重设一个initial-scale，比如设为2.0？可是这样不就意味着我们必须针对每个设备不同的像素密度以及设备宽度来设置initial-scale么？这……已经可以弃疗了 DPR为了不让艰辛的前端程序员们弃疗，设备厂商也很早就考虑好了这种问题。以苹果公司为早起代表提出了DPR(Device pixel ratio)这个专门为CSS准备的概念。 它是什么意思呢？ 设备像素比DPR(devicePixelRatio)是默认缩放为100%的情况下，设备像素和CSS像素的比值 这个定义读起来……反正我读着很头疼，关键是因为缩放的定义说不清。所以我理解的时候做了一些修正。 按照我们上一篇讨论的结果，缩放的实质就是映射。那100%的缩放就是不缩放也就是不映射 不映射？根据我们对移动端映射情况的总结，就是说initial-scale=1 &amp;&amp; scaleRatio = 1。 所以我的定义就是 DPR(devicePixelRatio)是无其它映射情况下，设备像素和CSS像素的比值 为什么要多写其它两字？因为DPR本身也是种映射……比如说在无其他映射的情况下，一个16px的文字，在DPR=2的设备上，就会被映射成2个实际的设备像素。 那有映射情况下的计算就是简单的数学比例关系的问题。 我们修改一下我们的映射关系 移动端：未缩放时html =&gt; browser = 1 : device.width / (default_html_width * DPR)缩放时html =&gt; browser = 1 : device.width * scaleRatio / (default_html_width * DPR) 好了，这样子就完美了。我们再重新看这个东西，device.width是常量，DPR呢？我们说这个是由设备厂家给出的定值，比如苹果厂家为iphone5设计的DPR=2，而default_html_width也是常量。 那么我们可以重新定义default-initial-scale = device.width / (default_html_width * DPR); 移动端：未缩放时html =&gt; browser = 1 : default-initial-scale缩放时html =&gt; browser = 1 : scaleRatio * default-initial-scale 这时候我们看起来又回到了原始的位置……但其实我们再次尝试设置initial-scale的时候 全新的initial-scale因为device.width / (default_html_width * DPR)中的device.width，DPR是绝对不会变的，只有html_width有商量的余地。 所以当你修改initial-scale的时候，仍然只会影响html_width的值。 html_width = device.width / (DPR * initial-scale) 继续来看设备A和B，这次设备厂家给我们提供了新数据 A设备：物理尺寸：10cm * 20cm像素： 320cm * 640cm像素密度： 32px/cmDPR：1 B设备：物理尺寸：10cm * 20cm像素： 640cm * 1280cm像素密度： 64px/cmDPR：2 如果按照上面的计算规则，在我们把initial-scale都设为1的情况下，对于一个16px的文字 A设备：html_width = 320 / (1 * 1) = 320映射关系： 320 =&gt; 320实际像素： x / 16 = 320 / 320 =&gt; x = 16px实际长度： l = 16px / 32(px/cm) = 0.5cm B设备：html_width = 640 / (1 * 2) = 320映射关系： 320 =&gt; 640实际像素： x / 16 = 640 / 320 =&gt; x = 32px实际长度： l = 32 / 64 = 0.5cm 欢呼吧，只要设备厂家给定了合适的DPR的值，你的initial-scale=1就可以正常工作了！ 这些思路我理解了，可是……这种技术就叫做……initial-scale技术么？如果你学过面向对象程序设计，也知道那些设计模式，你就该知道一个合理的名字对于技术交流有多么重要。 不过一个东西有了名字也是个麻烦事，因为我们都遇到过两个人对同一个名词有着完全不同的理解的情况。 所以说无论是我上面自己扯出来的映射，还是各种大神们说的缩放，有些意义上是相同的有些则有一点点区别，不存在名字上好不好的问题，只有对你好不好理解的问题。所以…… 你理解就好 就比如说这个“初始缩放”我一直认为它应该只是个映射而不该当成（我理解的）缩放……即便缩放本质上就是映射…… 现在，我们在理解这些原理的基础上，看一看标准化，或者说一些已经成文的东西。 &lt;meta name=”viewport”&gt;这个标签最早是苹果提出来的，为的就是能在移动端设置html_width。我们可以在html的head中写如下语句 &lt;meta name=&quot;viewport&quot; content=&quot;width=400&quot;&gt; 意思就是让html_width=400px，不过这种设置方法……不会影响到initial-scale。说的清楚一点就是……你如果这么写，你的initial-scale = default-initial-scale = device.width / (default_html_width * DPR)，而不是你期待的device.width / (400 * DPR)。 如果你希望修改initial-scale &lt;meta name=&quot;viewport&quot; content=&quot;width=400, initial-scale=1&quot;&gt; 还记得我们刚提到initial-scale时，我们（好吧，至少是我）的错误理解么？现在我们就得到了这种效果……一个html_width固定为400px的html被1:1映射到了屏幕上……所以说，对于DPR映射后320px的设备，你每次只能看见html的80%。 不过你愿意思考的话可以想想在DPR映射后320px的设备上 &lt;meta name=&quot;viewport&quot; content=&quot;width=200, initial-scale=1&quot;&gt; 会发生什么？留白吗？也有可能是黑边？还是说？……留个悬念自己用Chrome测试一下吧 当然你也可以只写initial-scale &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot;&gt; 哈，这就是我们正确理解的initial-scale，这种设置会计算出html_width=device.width，我们也可以把它设置成其它数字检验一下我们的理解是否正确。 不过你可能最喜欢的写法是这样 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 因为这是兼容性最好的方案（兼容了IE10转为横屏时按照initial-scale=1不能铺满屏的问题orz） 三类Viewportviewports剖析","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"},{"name":"响应式","slug":"响应式","permalink":"/tags/响应式/"}],"keywords":[]},{"title":"JS模块化规范","slug":"JS模块化规范","date":"2017-04-16T11:54:06.000Z","updated":"2020-01-14T02:33:27.634Z","comments":true,"path":"2017/04/16/JS模块化规范/","link":"","permalink":"/2017/04/16/JS模块化规范/","excerpt":"CommonJSCommonJS是什么？JS模块化的规范之一，主要用于非浏览器环境 诞生背景在非浏览器环境下编程需要良好的模块管理，而且能让每个模块在其自身作用域中执行。 代表应用Nodejs 核心思路通过文件组织模块，文件内的定义对模块私有每个模块通过module.exports导出，通过require()导入","text":"CommonJSCommonJS是什么？JS模块化的规范之一，主要用于非浏览器环境 诞生背景在非浏览器环境下编程需要良好的模块管理，而且能让每个模块在其自身作用域中执行。 代表应用Nodejs 核心思路通过文件组织模块，文件内的定义对模块私有每个模块通过module.exports导出，通过require()导入 核心对象require——引用//默认情况相当于，请注意引用关系及覆盖写值的问题 var require = module.require; require() 读入并执行js文件(后缀默认为’.js’)，返回该模块的module.exportsrequire.resolve() 获取上次加载的文件名require.cache[module] 缓存require.main 是否无调用者require.extensions 根据文件的后缀名，调用不同的执行函数 定位方式 require(‘/path’) 绝对定位 require(‘./path’) 相对定位 require(‘module’) 从node_modules中加载或从核心模块中加载 require(‘module/path’) 从module处寻找路径 Not found 尝试.js,.json,.node 加载过程 检查Module._cache中是否缓存，若缓存则直接返回 创建新的Module实例并加入缓存 找到模块目录 寻找package.json中的main字段对应文件 2失败，加载目录下的index.js/index.node 执行文件 过程出错则从缓存中删除文件 返回模块的module.exports拷贝 发生循环依赖时：部分加载 exports——导出//默认情况相当于，请注意引用关系及覆盖写值的问题 var exports = module.exports; module——自身定义module.id 标识符，通常是带有绝对路径的模块文件名module.filename 绝对路径文件名module.loaded 是否已加载完module.parent 调用该模块的模块module.children 该模块调用的模块数组module.exports 导出内容 执行过程同步执行，顺序执行每个模块只在第一次加载时运行并缓存结果，后续加载则读取缓存 AMDAMD是什么？Asynchronous Module Definition 诞生背景服务器端的Nodejs依照CommonJS规范开创了JS模块化编程的新局面，我们希望在客户端也能进行模块化编程。问题在于服务器端的模块都存储在本地，加载延迟很小。而客户端则需要从服务器端加载模块延迟很大，不能使用CommonJS的同步加载。 代表应用require.jscurl.js 核心对象define(id?, dependencies?, factory); 执行过程异步执行","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"/tags/Javascript/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"模块化","slug":"模块化","permalink":"/tags/模块化/"}],"keywords":[]},{"title":"Web移动端适配基本原理","slug":"Web移动端适配基本原理","date":"2017-04-15T14:11:03.000Z","updated":"2020-01-14T02:33:50.020Z","comments":true,"path":"2017/04/15/Web移动端适配基本原理/","link":"","permalink":"/2017/04/15/Web移动端适配基本原理/","excerpt":"这几天看了一些移动端适配的方案，来写一下这篇讨论。理解可能有欠缺之处，欢迎指出。 从PC端讲起虽然这篇是总结移动端的，但是考虑到像我这种学习前端的萌新都是从PC端开始练起，所以我们就先来看下在PC端做前端开发的情况。 写一个h5页面。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 什么？这不是HTML入门的第一个页面么？这有什么看头？ 别急呀，我们现在来看这个页面可不是学标签的。作为一名成长中的前端开发人员，在看到页面的时候要习惯性地问自己一些问题的。比如说对这个页面里，h1到底有多宽? 解决问题的最有效方法是提出最正确的问题","text":"这几天看了一些移动端适配的方案，来写一下这篇讨论。理解可能有欠缺之处，欢迎指出。 从PC端讲起虽然这篇是总结移动端的，但是考虑到像我这种学习前端的萌新都是从PC端开始练起，所以我们就先来看下在PC端做前端开发的情况。 写一个h5页面。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 什么？这不是HTML入门的第一个页面么？这有什么看头？ 别急呀，我们现在来看这个页面可不是学标签的。作为一名成长中的前端开发人员，在看到页面的时候要习惯性地问自己一些问题的。比如说对这个页面里，h1到底有多宽? 解决问题的最有效方法是提出最正确的问题 分析一下，首先我们知道h1是一个块级元素，那么块级元素的宽度是怎么定义的呢？ 块级元素占据其父元素（容器）的整个空间 现在，h1有多宽的问题就变成了另一个问题：h1的父元素——也就是说body,有多宽？ 因为我们没有定义body，但根据开发经验我们都知道，不就是100%么（不考虑浏览器自带的padding和margin的话）？但是如果是100%，我们知道百分比是相对大小，那么这个100%是相对于哪个元素来说呢？ 唔……应该是浏览器宽度吧，body哪里还会有相对的父元素呢？不，确实有，这是因为我们平时开发时，很少关注一个重要的标签，也就是HTML真正的包裹标签——html。 我们做一个实验，在Chrome下F12打开Console，然后给html加一个width:50%，再查看body的宽度，发现body和html具有一样的宽度。也就是说，默认情况下，body的宽度是相对html的100%。那么问题就成了html有多宽呢？这回总该是浏览器的宽度了吧？ 没问题，至少，据我所知在PC端的情况下没问题。不要担心我欺骗你们，我们后面会用一些实验证明这一点的。 不过这句话的意思是，在移动端就不是这样了么？html的默认宽度不是浏览器的宽度还能是什么？是什么呢？亲自看一下吧。 阶段结论 在PC端下，html默认宽度恒等于浏览器宽度 转战移动端我这里的意思不是说把上面的网页拷贝到手机上运行，那样太麻烦了，会让人放弃前端开发的。庆幸Chrome里面为开发者提供了一个移动端模拟模拟器。 还是上面那个网页，我们使用用Chrome Console里自带的模拟移动端的功能查看效果（Win键盘快捷键Ctrl+Shift+M）我们可以在模拟界面最上面看到我现在模拟的是iphone5的手机(啊，还是很希望有一部真的果机来测试2333)，它的屏幕大小是320x568px，后面的100%意思是在浏览器里显示的屏幕大小，是它在真实世界里大小的100%。 然后按照PC端的思路，html是浏览器的大小，在这里就该是320px，我们看一下。嗯？发生了什么，好像和想象中的不太一样……我们看到在320px宽度的设备上，html标签宽度的计算结果是980px？这难道只是Chrome移动端计算元素宽度时的BUG？ 嗯，让我们修改一下html的代码。我想你应该知道在PC端如果想让一个元素隐藏除了用display:none或者visibility:hidden（PS：如果你不知道这两个方法，建议研究一下它们的区别。What is the difference between visibility:hidden and display:none?）还可以把它移动到可见范围之外，比如在1080宽的屏幕上可以left:1080px（当然……没人会蠢到写这种东西吧，这里只是为了实验。如果想实现这种效果请不要使用px这种绝对长度作为单位），我们希望在320px宽度的手机上也实现类似的效果。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;p style=&quot;position: absolute; left: 600px&quot;&gt;I shouldn&#39;t be seen under the smartphone whose device-width is lower than 600px&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 然后假设你忘了亲自看一眼就自信的把它提交给了测试……不出1分钟，你就会获得一个BUG反馈这是什么鬼？怎么能让用户看到这种东西？！ 写前端在时间允许的情况下，请务必多调试多调试多调试，在100种设备上调试都不为过 很好，现在你应该理解了，html的宽度在移动端的奇怪现象了吧。但是如果这个现象真的不合理，那么全世界的程序员不会这么长时间都坐视不理的。 那么现在的问题是：为什么要在一个320px宽的设备上把html宽度设定成“不规矩”的值呢？ 阶段结论 在移动端下，html宽度不一定等于浏览器宽度 移动端设备厂商 &amp; 移动端浏览器厂商：我们希望给用户尽可能好的视觉体验现在暂时回到几年前，那时候以iPhone和Android为代表的智能机还没出现在市场。没有多少人能想到，现在的我们可以抱着装在口袋里的东西浏览各种高端酷炫的网页，手机上能把html加载出来再把基本的CSS支持一下就已经很了不起了。所以说当然也没有人闲的无聊会想着去开发一些能够在320px宽度下正常显示的页面。 所以当智能机出现的时候，设备厂商和浏览器厂商费尽心思要做的第一件事儿就是，想办法让PC上那些横向设计的html，正确且正常的在320px宽（甚至更窄）的设备上显示。WOW！这个想法很棒，我们只要把大的页面映射到小的屏幕上就可以解决问题了。 映射？这似乎是一个新概念，但是我们大概很久以前就在接触它了。 如果你学过一些图像处理的知识，你应该知道要把一张2*2像素的图片显示到4*4像素的设备上，最简单的方法只需要把原始图片每1个像素(1*1格)，复制到设备中的4个像素(2*2格)上就可以了,这就是一种基本的1=&gt;2映射。当然也可以反过来把4*4像素的图片显示在2*2的设备上，只需要只取奇/偶数行奇/偶数列，或者做一些均值计算就可以了，这就是一种2=&gt;1映射 但是还剩一个问题……我们怎么知道html应该有多宽？我们刚才知道在PC端html的宽度是由浏览器宽度决定的？但是在移动端呢，应该让html取多宽？ 至于这一点的答案……认真考虑一下其实就能得出，具体多宽其实无所谓，只要足够宽能够防止html下的元素挤在一起就好，当然如果太宽的话，在“初始缩放”映射后，就会导致那些按绝对尺寸定义的元素显得太小。 不过比起随机选一个“足够宽”的数，为所有网页统一定义一个默认宽度明显比较方便。 遗憾的是，这个数字怎么选择并没有一个固定的标准。各个设备厂商&amp;各个浏览器厂商完全可以由着自己的性子来。它们一般都选在768px ~ 1024px之间的一个数，大多数都选择了980px。 我们现在不打算讨论视图的问题，所以我们姑且叫这个数字为default_html_width。 这样，页面在移动端加载时，移动端浏览器会将html.width设定为default_html_width，之后为页面建立一个default_html_width =&gt; device_width的映射关系，这个映射关系被苹果公司叫做“初始缩放”，虽然我觉得这个名字……很糟糕(它和下面说的缩放混为一谈了)，但大家现在都么叫。 我们现在可以考虑在浏览器加载HTML时，发生了如下对话 PC端 HTML页面妹子：浏览器大叔，我要请你帮我绘制一下，请问你能给我的最大的绘制空间是多少呀？ 浏览器大叔：哦，好的，我查一下，我现在有1080px的宽度可以让你绘制 HTML页面妹子：嗯嗯，我知道了，谢谢大叔。（把1080作为html标签的宽度） 移动端 HTML页面妹子：浏览器大叔，我要请你帮我绘制一下，请问你能给我的最大的绘制空间是多少呀？ 浏览器大叔：哦，好的，我查一下……（……怎么只有320px，不够妹子用啊！好在爹爹以前教导我，遇到这种情况，就告诉妹子有980px，然后我来把它映射到320px就好了）……哦，我现在有980px的宽度可以给你绘制 HTML页面妹子：嗯嗯，我知道了，谢谢大叔。（把980作为html标签的宽度） （之后HTML妹子在绘制的时候，浏览器大叔都会把HTML妹子绘制的像素映射到设备实际的像素） 那么现在事情就变得有意思了，比如说，CSS设置的一个width:100px的button，在宽度为320px宽的设备下实际占多少像素呢？ 哈，这个数学题还是难不倒我们的。如果按照default_html_width是980px考虑的话，那么实际像素x有映射关系x / 100 = 320 / 980, x = 33px。取整是因为没人（也没有机器）知道怎么渲染半个像素。 不过这个按钮有多大或许不甚重要（不过你要是不小心弄出了一个超级大的按钮，估计设计师会追着打你……）,这里更重要的东西是写在代码里的像素需要经过映射才能变为设备上的像素。 这就有点复杂了，不过问题还没完…… 阶段结论 设备厂商&amp;浏览器厂商会为网页选定一个default_html_width，并以此为基础建立“初始缩放”映射关系 写在代码里的像素需要经过映射才能变为设备上的像素 天呀，这个网页上的字实在是太小了在default_html_width = 980px的情况下，对于正常情况下一个16px的汉字（它在PC端显示很正常），放到移动端占据的真实像素就是5px。下面的这个显示的效果，就是真实世界里的效果，没有进行缩放，你也可以拿真机试试。别说是文字了，就连标题读起来都心累。 我们要理解，之所以移动端显示PC的页面要经过“初始缩放”映射。是让用户能知道页面各个位置的布局和功能。 但是至于看清了布局能不能看清文字……单凭“初始缩放”映射还真解决不了这个问题，所以用户就会双击触屏或者进行手势操作，对他感兴趣的部分进行放大（当然之后很可能还会缩小回原来的样子）…… 嗯……等等……放大……放大……放大？ 我们对比一下在PC端的经验，有些时候我们在浏览网页的时候偶尔也会调节浏览器的大小。这也是一种放大缩小的行为，那么这个行为是不是和手机端的缩放原理一样呢？ 我们知道在PC上，如果为body的直接子元素定义相对宽度的话，当浏览器大小改变时（更准确地说是浏览器大小改变引发了html尺寸的改变），该子元素占据的像素数会被重新计算。我们看一下这个过程（仅在PC端有效）： 定义相对宽度的元素是根据其父节点宽度的像素值计算而来的 当父节点宽度改变的时候子节点会重新计算宽度像素值 html的宽度默认恒等于浏览器宽度 浏览器宽度改变时，html宽度改变，body被重新计算，body下所有定义相对宽度的子元素均重新计算。 Talk is cheap, show me the code 我们来实际看看浏览器大小改变时的效果。 首先把之前的代码改一下。我们来准备一个占body100%大小的ul，为了能观察到变化情况，在下面添加10个li，内容对应0-9，每个宽度占据ul的10%。 哦，我忘了li是块级元素，不能并排在同一行。不过没关系，我们把它改成行内块级（display:inline-block）元素，这样就可以在显示在行内的情况下修改它的宽度。（ps:行内非替换元素修改width属性无效，如果你不知道，请看) what is a non-replaced inline element? Inline elements and padding Visual formatting model details 另外，在设置inline-block的时候需要特别注意标签间的空格以及分行，因为它们都会被浏览器当做内部的文本节点” “（占据1em的大小）被渲染出来。 最后，为了让每个元素占据的空间更明显，我们给它设置一个1px的border。但这会导致li的盒模型在content-area.width = 10% * ul.width的基础上，左右两边各多出1px那么10个li合起来就占据了(10% * ul.width + 2) * 10的宽度，很明显超出父元素20px，导致换行。 这时候我们可以设置box-sizing:border-box;意思就是width:10%这个宽度包含了content,padding,border的全部内容。（也可以用calc函数动态计算width） 参见CSS3 box-sizing 属性CSS3 calc() 函数 然后我们的样式有点多了，最好把它们都提出来，标签内嵌样式实在是太丑陋了。下面是修改后的代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .p_should_hide{ position: absolute; left: 600px; } .100button{ width: 100px; } .16font_size{ font-size: 16px; } ul{ width: 100%; padding: 0; margin: 0; } ul li{ display: inline-block; width: 10%; box-sizing: border-box; border: 1px solid #000; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;p class=&quot;p_should_hide&quot;&gt;I shouldn&#39;t be seen under the mobile browser&lt;/p&gt; &lt;button class=&quot;100button&quot;&gt;我是100px宽的按钮&lt;/button&gt; &lt;p class=&quot;16font_size&quot;&gt;设计师给我的设计方案是16px,看起来在PC上很优雅&lt;/p&gt; &lt;ul&gt; &lt;li&gt;0&lt;/li&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;4&lt;/li&gt;&lt;li&gt;5&lt;/li&gt;&lt;li&gt;6&lt;/li&gt;&lt;li&gt;7&lt;/li&gt;&lt;li&gt;8&lt;/li&gt;&lt;li&gt;9&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 我们可以看到在PC下，窗口放小的过程中，html一直等于窗口的宽度，并且ul,li的宽度一直被重新计算导致所有计算结果的原因归根结底就是PC端html的宽度恒等于浏览器的宽度。 让我们回到移动端，html的宽度……额……和浏览器的宽度，有一个“初始映射关系”。而且在缩放过程中，移动端浏览器的宽度也根本不会变啊。 所以结论很明显，移动端的缩放机制和PC端浏览器窗口大小改变的原理绝对不一样。 那么新的问题又来了，移动端缩放的过程中到底发生了什么？ 阶段结论 html元素宽度的改变的根本原因在于html宽度的改变 移动端的缩放机制和PC端浏览器窗口大小改变的原理不一样 PC上的缩放移动端缩放这个问题，还是有点复杂。 但我们先不管移动端，只考虑缩放的问题。 不知道你有没有注意过，其实现代的PC浏览器上一般都会有缩放的功能，这是为了满足一些视力不太好的用户（当然有时候也能帮助一些设计尺寸很反人类的网页）的需求 在Chrome下按Ctrl+”+”/“-“,或者Ctrl+鼠标滑轮滚动就能实现页面的缩放。 我们对之前的页面进行175%的缩放哈，这下可就麻烦了，我们在上面讨论中的第一个结论就是PC端下html默认宽度恒等于浏览器宽度，但是这里明显出了问题，我现在的浏览器宽度是1366px，但是html的计算宽度却只有780.57px。看来我们需要修改一下最初的结论 在PC端不进行缩放的情况下，html默认宽度恒等于浏览器宽度 这个结论看起来比之前的那个更复杂了，但是其实这并不会造成太大的问题。因为PC端在布局合理的情况下，很少有用户会开着缩放浏览你的页面呢？ 在这里真正有启发性的是缩放的本质，我们计算一下，1366 / 780.57，我的计算器显示为1.750003203，也就是我们的缩放比例。 现在我们可以来梳理一下PC端缩放的过程了： 用户通过缩放工具选择了某个缩放比例 计算缩放后html.width = browser.width / scaleRatio 计算html后代元素的尺寸 重设映射关系html.width =&gt; browser.width关于前面三点都是旧概念了，但这里的第四点重置了映射关系！所以缩放本质上讲就是一种映射关系的改变。 阶段结论 在PC端不进行缩放的情况下，html默认宽度恒等于浏览器宽度 PC端缩放会改变html.width 缩放本质上讲就是一种映射关系的改变。 移动端的用户缩放好啦，理解了缩放，再来看移动端缩放。 还是拿上面的页面，我们利用Chrome模拟器在移动端进行放大测试（在Chrome模拟器调试时，双击页面进行放大）唔，这个显示的效果太小了，但我不想利用CSS把它变大，那样不定会导致更麻烦的属性计算问题。 但亲自看一遍放大过程或者数格子就能看出来，在移动端放大后只显示了8.5个格子，查看html的宽度，它还是980px。唔……这就麻烦了，同样是缩放，PC端改变了html的宽度而移动端却没有这么做……但仔细考虑一下这样是合理的，理由就是移动端的浏览器宽度通常很窄。 移动端的浏览器宽度通常很窄，如果在缩放时执行了html.width = origin_html.width / scaleRatio，那么下面的所有定义了相对宽度的元素都会被缩放，然后再进过html.width =&gt; browser.width的映射，那么页面上所有的元素就会挤在你小小的屏幕上，即便它们都被放大到很大的倍数……想象一下，那简直就是一锅粥。(tip:如果你想象不到那会有多造，把你的浏览器尺寸拉到最小，然后使用缩放工具试一下你就知道了……) 我们现在解决原始的问题移动端用户缩放时发生了什么： 用户通过手势（扩大手势，缩小手势或者双击）进行 重置映射关系为 (html.width / scaleRatio) =&gt; browser.width 我们还是看那个CSS中定义为100px的button，移动端尺寸宽320px，default_html_width为980px，根据之前的计算，这个按钮在不经过缩放的情况下占据实际像素33px。 现在用户进行了一个放大2倍的手势操作。 初始映射关系：980px =&gt; 320px 放大后映射关系： (980 / 2)px =&gt; 320px 现在再来计算button显示的宽度x: x / 100 = 320 / 490, 得x = 65px。 太棒了，现在我们可以精确知道用户缩放以后的像素了。可是先别急，因为只是知道这个像素……其实……基本上可以说没有任何意义。 阶段结论 移动端用户缩放时不会改变html.width，只会修改映射关系。 北京到杭州的距离是……1568……px?作为前端开发人员，我们和设计师交流的必然会涉及px。这个按钮100px，这个div要左移1px等等。而且经过上面的讨论，我们也知道了，在CSS中写好的像素需要经过映射才呈现出实际的像素。 不过我还是有个问题，就是到底需要多大的按钮，才能保证用户很容易用手指点中？ 略微思考后，你可能想回答某一个像素值，而且它应该是基于实际像素的，但这个像素值有实际意义么？其实换个角度想，这个问题正确的问法应该是，用户的手指一般有多粗？既然如此……像素值有意义嘛？这就好比我问你北京到杭州有多远，你思考了一阵告诉我……1568……px。 很明显，现在我们又引出了新的问题，就是1px，在现实世界里，到底该有多长？老师在学校没有教过你这类单位转换，当然也不可能在某某标准单位定义里找到相关的东西。 也就是说，1px的实际长度完全可以是任意的！ 好吧，我们好不容易解决了缩放的问题，确定了实际显示的像素大小，但现在却被告知这个大小完全没有意义，它可能代表1cm,1m甚至1km…… 怎么办呢？我们完全可以要求全世界的人，规定一个统一的换算单位，比如1px=1cm。但这明显不合理，比如说你想要显示一张1080*763的图片，你就必须购买一个1080*763cm的设备……要不然全世界只有少的可怜的几种固定大小的图片，要不然你就得为了欣赏各种图片买齐各种大小的设备…… 如果你以前做过任何和图像有关的事情，或者你在学计算机的时候学习过显示器的知识，你就应该知道有一个叫图像分辨率的概念（为了把它和显示分辨率区别，一般都叫它像素密度……但我觉得分辨率的率本来就该含有密度的意思），它代表了每个单位长度中包含的像素数，但遗憾的是，它的单位长度用的是英寸……作为中国人，我对英寸这个概念实在是没什么亲切感，为了便于后面的理解，请允许我在这篇文章里讨论细节的时候把单位长度换成cm（其实无所谓啦，只是个等比例换算问题而已）。 我们这里就假设有一个宽10cm，高20cm的设备，它的像素密度是32px/cm，所以说它的像素为320*640，我们就叫它设备A吧。还有一个同样宽10cm，高20cm的设备，它的像素密度是64px/cm，像素就是640*1280，我们叫它设备B。 我们来看看那个CSS定义的100px的button在这两个设备上会怎么被映射？ A设备：default_html_width = 980px映射关系： 980 =&gt; 320实际像素： x / 100 = 320 / 980 =&gt; x = 33px实际长度： l = 33px / 32(px/cm) = 1cm B设备：default_html_width = 980px映射关系： 980 =&gt; 640实际像素： x / 100 = 640 / 980 =&gt; x = 65px实际长度： l = 65px / 64(px/cm) = 1cm WOW！我们发现只要设备厂家和浏览器厂家给出了相同的default_html_width，那么按照映射关系，即便button实际占据的像素数不同，但最后的实际长度基本上是相等的。 不过实际像素的不同会有什么影响呢？比如说我们的button用了一个从左向右的渐变色，再假设渐变方向上的每个元素都有一个新的颜色值。那么对于设备A，就有33种颜色，而设备B有65种颜色。所以这就是高分辨率的意义。 最后我们整理一下在没有用户缩放影响下的实际长度计算公式 CSS_px =&gt; CSS中定义的像素device_px =&gt; 设备的像素数default_html_width =&gt; 设备厂商&amp;浏览器厂商给定的默认html宽度PPI =&gt; 设备像素密度device_length =&gt; 设备实际长度 实际像素： device_px * CSS_px / default_html_width实际长度： (device_px * CSS_px) / (PPI * default_html_width) = device_length * CSS_px / default_html_width 好，现在我们把这篇文章里的两个主要话题结合起来讨论一个主题作为结尾： 移动端的缩放 移动端的像素密度 我们要讨论的是，如何充分利用高分辨率屏幕的分辨率。出于某些原因（下一篇我们会讨论这些原因），default_html_width = 320px 然后我这里有一张宽320px的图像，我希望让它显示在页面最上面并且充满浏览器的宽度。 根据之前学会的计算方法，我们很容易得到： A设备：映射关系： 320 =&gt; 320实际像素： x / 320 = 320 / 320 =&gt; x = 320px实际长度： l = 320px / 32(px/cm) = 10cm B设备：映射关系： 320 =&gt; 640实际像素： x / 320 = 640 / 320 =&gt; x = 640px实际长度： l = 640 / 64 = 10cm 看起来似乎没什么问题。但是…… 用户利益至上 我们可以看到，一张320px的图片，在设备B上却实际占据了640px的像素数。换句话说，用户花钱买了高分辨率的设备，就是希望能有更好的用户体验，但是这里却给了他们和设备A相同的结果……（甚至更糟糕……很多图片因为强行放大会变的很奇怪） 站在你的用户的角度考虑，这肯定不合理。那么我们可以为B设备的用户提供更清晰的图片嘛？比如说宽640px的图片。 B设备：实际像素： x / 640 = 640 / 320 =&gt; x = 1280px实际长度： l = 1280 / 64 = 20cm Oh!太糟糕了，这样子的话在设备A，B上显示的结果就不一致了。 怎么办呢？可不可以利用缩放把图片缩放0.5倍？当然不行……你可以算一下，因为移动端缩放不影响html.width，所以页面内所有元素宽度都不变，然而你把映射关系改成了原像素的0.5倍，那么整个页面的所有元素都会被缩小0.5倍。所以A，B设备之间还是不一致。 但如果我们修改的是html.width呢？或者说，我们修改了B设备的default_html_width。比如说把它改成640px，是不是就解决问题了。 当然，所以这里的正确问题是能不能修改default_html_width的值，或者换句话说，能不能修改“初始缩放”映射关系呢？ 好吧，关于这个的答案当然可以，但是具体的内容就放到下一篇讲吧。 阶段结论 显示在设备上的实际像素并不代表用户最终见到的尺寸 在没有缩放的情况下，影响最终用户见到的尺寸的因素包括：设备长度，CSS定义，default_html_width 总结结论 在PC端不进行缩放的情况下，html默认宽度恒等于浏览器宽度 在移动端下，设备厂商&amp;浏览器厂商会为网页选定一个default_html_width作为默认html.width，并以此为基础建立“初始缩放”映射关系:default_html_width =&gt; device_width 写在代码里的像素需要经过映射才能变为设备上的像素 缩放本质上讲就是一种映射关系的改变。 html元素宽度的改变的根本原因在于html宽度的改变 移动端的缩放机制和PC端浏览器窗口大小改变的原理不一样 PC端缩放会改变html.width 移动端用户缩放时不会改变html.width，只会修改映射关系。 显示在设备上的实际像素并不代表用户最终见到的尺寸 在没有缩放的情况下，影响最终用户见到的尺寸的因素包括：设备长度，CSS定义，default_html_width","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"},{"name":"响应式","slug":"响应式","permalink":"/tags/响应式/"}],"keywords":[]},{"title":"CSS居中方案","slug":"CSS居中方案","date":"2017-03-05T21:57:51.000Z","updated":"2020-01-14T02:33:24.257Z","comments":true,"path":"2017/03/06/CSS居中方案/","link":"","permalink":"/2017/03/06/CSS居中方案/","excerpt":"垂直居中单行小元素、文本、图片设置line-height &lt;div class=&quot;vertical&quot;&gt;content&lt;/div&gt; .vertical{ line-height: 20px; } 原理：上下半行间距相等 高度固定时利用绝对定位和负值margin","text":"垂直居中单行小元素、文本、图片设置line-height &lt;div class=&quot;vertical&quot;&gt;content&lt;/div&gt; .vertical{ line-height: 20px; } 原理：上下半行间距相等 高度固定时利用绝对定位和负值margin 自身负margin &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;vertical&quot;&gt;content&lt;/div&gt; &lt;/div&gt; .container{ position: relative; } .vertical{ height: 100px; position: absolute; top: 50%; margin-top: -50px; /* height / 2 */ } 原理：利用绝对定位将元素移至中心，然后利用负margin平移元素 兄弟元素负margin &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;before_vertical&quot;&gt;&lt;/div&gt; &lt;div class=&quot;vertical&quot;&gt;content&lt;/div&gt; &lt;/div&gt; .container{ height: 100%; } .before_vertical{ height: 50%; margin-bottom: -50px /*(/vertical).height / 2 */ } .vertical{ height: 100px; } 原理：利用兄弟节点占据一半高度，再利用负margin修改文本流 对于现代浏览器自适应内容高度时 利用display:table &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;vertical&quot;&gt;content&lt;/div&gt; &lt;/div&gt; .container{ height: 300px; display: table; } .vertical{ display: table-cell; vertical-align: middle; } 原理：vertical-align在table-cell中有效 利用兄弟节点 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;vertical&quot;&gt;&lt;p&gt;test&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;extra&quot;&gt;&lt;/div&gt; &lt;/div&gt; .container{ height: 600px; } .vertical, .extra{ display: inline-block; vertical-align: middle; } .extra{ height: 100%; } 原理：在inline-block的情况下，让vertical元素与占满容器高度的兄弟元素中部对齐 容器高度不确定利用上下padding &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;vertical&quot;&gt;&lt;/div&gt; &lt;/div&gt; .vertical{ padding-top: 30px; padding-bottom: 30px; } 原理：用相等的上下padding占据容器上下边（PS：对于块级元素用margin应该也可以） 其它情况用js…… 水平居中居中元素宽度确定时 利用margin的auto属性 &lt;div class=&quot;horizontal&quot;&gt;content&lt;/div&gt; .horizontal{ width: 200px; margin: 0 auto; } 原理：当水平margin为auto时，浏览器在计算位置时会自动将元素居中处理 利用负margin &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;horizontal&quot;&gt;content&lt;/div&gt; &lt;/div&gt; .container{ position: relative; } .horizontal{ width: 200px; position: absolute; left: 50%; margin-left: -100px; /* width / 2 */ } 原理：同垂直居中 宽度自适应居中对行内元素设置text-align &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;horizontal&quot;&gt;test0&lt;/div&gt; &lt;div class=&quot;horizontal&quot;&gt;test1&lt;/div&gt; &lt;/div&gt; .container{ text-align: center; } .horizontal{ display: inline-block; } 原理：利用text-align的行内对齐功能 对float元素居中利用嵌套的相对位移 &lt;div class=&quot;float_container&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;horizontal&quot;&gt;test0&lt;/div&gt; &lt;div class=&quot;horizontal&quot;&gt;test1&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; .float_container{ float: left; position: relative; width: 100%; } .container{ clear: left; float: left; position: relative; left: 50%; /* 相对100%的总宽度 */ } .horizontal{ float: left; position: relative; right: 50%; /* 相对container的宽度 */ } 原理：container相对总宽度移动50%，其左边线位于中心。居中元素相对container反向移动50%,其中间元素的中心将与container左边线对齐。 利用CSS3 flex布局 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;horizontal&quot;&gt;test0&lt;/div&gt; &lt;div class=&quot;horizontal&quot;&gt;test1&lt;/div&gt; &lt;/div&gt; .container{ display: flex; display: -webkit-flex; display: -ms-flex; display: -moz-flex; justify-content: center; -webkit-justify-content: center; -ms-justify-content: center; -moz-justify-content: center; } 原理：深入了解 Flexbox 伸缩盒模型 fit-content &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;horizontal&quot;&gt;test0&lt;/div&gt; &lt;div class=&quot;horizontal&quot;&gt;test1&lt;/div&gt; &lt;/div&gt; .container{ width: -webkit-fit-content; width: -moz-fit-content; width: fit-content; margin: 10px auto; } 原理：理解CSS3 max/min-content及fit-content等width值 参考 CSS制作水平垂直居中对齐 六种实现元素水平居中 Horizontally Centered Menus with no CSS hacks","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Web","slug":"Web","permalink":"/tags/Web/"},{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"CSS常见知识汇总","slug":"CSS常见知识汇总","date":"2017-03-05T09:26:43.000Z","updated":"2020-01-14T02:33:18.234Z","comments":true,"path":"2017/03/05/CSS常见知识汇总/","link":"","permalink":"/2017/03/05/CSS常见知识汇总/","excerpt":"语法语义盒模型(Box Model) 内容(Content) 内容，背景，颜色，图片 内边距(Padding) 背景，颜色，图片 边框(Border) 外边距(Margin) 盒类型 containing boxes: 一个block inline boxes: block中的各个子块，分为非匿名（由行内标签产生）和匿名的（被行内标签分割或由CSS的content属性产生） line boxes: 每一行的文本 content area: 围绕文字的盒子，高度由font-size决定","text":"语法语义盒模型(Box Model) 内容(Content) 内容，背景，颜色，图片 内边距(Padding) 背景，颜色，图片 边框(Border) 外边距(Margin) 盒类型 containing boxes: 一个block inline boxes: block中的各个子块，分为非匿名（由行内标签产生）和匿名的（被行内标签分割或由CSS的content属性产生） line boxes: 每一行的文本 content area: 围绕文字的盒子，高度由font-size决定 字体font-size px相对于显示器屏幕分辨率的固定值 em相对不设置font-size时的尺寸进行乘法运算，默认1em = 16px rem相对于html(根元素)的font-size进行计算，&lt;=IE8的版本无效 vw, 1vw = viewport.width / 100 vh, 1vh = viewport.height / 100 vmin, min(vw, vh) vmax, max(vw, vh) 行高 行组成 顶线(top line) 中线(middle line) 基线(base line) 底线(bottom line) 相关名词 行高(line-height)：两行文字基线之间的垂直距离 行间距(line-height - font-height)：一行底线至下一行顶线的垂直距离 半行间距((line-height - font-height) / 2)：顶线到上行内框或底线到下行内框的距离 line-height属性可取值: normal(默认，1.0-1.2), inherit, 百分比, 长度(px/em), 纯数字写法: /* 单独 */ div{ line-height: normal; } /* 和font-size写在一起 */ div{ font: 100%/20px /*font-size: 100% &amp; line-height: 20px*/ } 继承: 百分比：继承自父元素的font-size * line-height 长度：继承值 纯数字：自己的font-size * line-height line-boxes’ heightheight = 行内所有非替换标签产生的inline-boxes中: max(line-height) padding &amp; margin百分比值均根据包含块的宽度计算 负外边距(negative margin)作用于width可确定的static元素(行内元素，定义width的块元素) margin-top, margin-left的负值会使元素向该方向平移 margin-bottom, margin-right的负值会使后续文本流元素被拉入 作用于width不可确定的static元素(未定义width的块元素)margin-left, margin-right的负值会使元素width增大 作用于浮动元素在“浮动流”中与文本流效果相似 外边距合并(margin collapsing) 邻近兄弟元素 父元素与第一或末尾子元素之间 空元素的上下外边框 vertical-align应用范围：inline-level, table-cell, ::first-letter, ::first-line 替换元素与非替换元素替换元素(replaced elements)浏览器根据其标签的元素与属性来判断显示具体的内容据我了解替换元素和空元素是同一类东西的不同分类方法eg. &lt;img/&gt; &lt;input/&gt; &lt;textarea&gt;&lt;/textarea&gt; &lt;select&gt;&lt;/select&gt; &lt;object&gt;&lt;/object&gt; 非替换元素(non-replaced elements)元素告知浏览器内容进行渲染。非替换行内元素设置垂直padding时不会影响行高（所以可能会和上方或下方的containing-box 重叠），但会影响内容区高度，设置垂直margin无意义。 浏览器主流浏览器渲染引擎 IE - Trident Safari - Webkit(WebCore + JSCore) Chrome - Chromium(&lt;Chrome 28.0.1469.0, Webkit分支)，Blink(Webkit分支) Opera - Elektra(Opera4-6), Presto(&lt;Opera12.17), Chromium, Blink Firefox - Gecko 主流浏览器JS引擎 IE - Chakra Safari - Webkit中的JSCore Chrome - V8 Opera - LinearA(Opera4.0-6.1), LinearB(Opera7.0-9.2), Futhark(Opera9.5-10.2), Carakan(&gt;Opera10.50) Firefox - 很多……最新的是OdinMonkey(&gt;Firefox22.0) CSS hack利用浏览器对CSS不同的解析特性，针对对不同浏览器的CSS控制 参考 Line Height (中文版) css行高line-height的一些深入理解及应用 深入理解CSS中的行高 负margin用法权威指南","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Web","slug":"Web","permalink":"/tags/Web/"},{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Node.js学习笔记2","slug":"Node-js学习笔记2","date":"2017-03-04T01:49:46.000Z","updated":"2020-01-14T02:33:34.898Z","comments":true,"path":"2017/03/04/Node-js学习笔记2/","link":"","permalink":"/2017/03/04/Node-js学习笔记2/","excerpt":"看到《Node.js实战》第三章了，这一部分讲的是Node.js的一些基础原理，挺长的，拆开慢慢看 模块管理首先是为了让代码结构更加优雅的模块管理，这里书上原图比废话更能解决问题。 包导出","text":"看到《Node.js实战》第三章了，这一部分讲的是Node.js的一些基础原理，挺长的，拆开慢慢看 模块管理首先是为了让代码结构更加优雅的模块管理，这里书上原图比废话更能解决问题。 包导出 包查找 包入口 异步编程然后知道怎么组织代码了，就来看Node.js的卖点异步编程吧。异步编程呢在Node里主要用两种方式实现。 回调（一般为一次性逻辑） 事件监听器（一般为重复性逻辑） 回调这个其实很好理解，就是说我告诉程序这个异步操作你先做着，我也不管你做多久（当然，太久的话有时候还是该管的……），我也暂时不管你得到什么结果，总之你做完这件事儿就去给我执行另一个函数就好了。 事件发射器这个其实做过点GUI编程的多少都该理解点意思，就是说平时没事儿干，就等事件（或者干点别的常规事务），然后来了事件，就响应它。 然后书中一开始实现了《UNIX网络编程》里的echo服务器……展示了一下Node的简洁性。 再然后，就出问题了……它基于net包实现了一个命令行上的聊天室。然而抄完代码，运行……嗯哼？每个客户自己发消息挺嗨，然而其它客户端就是不显示……忧伤。 用输出查了一下，是这里出的问题 var server = net.createServer(function(client)){ /* Some code here */ client.on(&#39;connect&#39;, function(){ //这个回调函数从来没触发过…… channel.emit(&#39;join&#39;, id, client); }); /* Some code here */ } 几个意思……明明连接都是成功的呀。 顺手stackoverflow一下，找到了两个解答 Node js net event : connect vs connection when is the ‘connect’ event in nodejs net module emitted? 其实这俩说了一个意思，就是net.createServer这个函数的回调响应的时候，其实已经完成了connection的事件了，其实这就相当于是在写 var server.on(&#39;connection&#39;, function(client)){ /* Some code here */ client.on(&#39;connect&#39;, function(){ //这个回调函数从来没触发过…… channel.emit(&#39;join&#39;, id, client); }); /* Some code here */ } 能等到这个事件才怪orz……所以把代码改成 var server = net.createServer(function(client)){ /* Some code here */ //直接emit就好，这时候已经完成connect了 channel.emit(&#39;join&#39;, id, client); /* Some code here */ } 然后自己还犯了个错误，把退出的时候触发的leave事件写到了join事件中 channel.on(&#39;join&#39;, function(id, client)){ /* Some code here */ channel.on(&#39;leave&#39;, function(id)){ channel.removeListener(&#39;broadcast&#39;, this.subscriptions[id]); channel.emit(&#39;broadcast&#39;, id, id + &quot; has left the chat\\n&quot;); } } 结果……一个客户端断开连接，每个客户都会触发一次退出消息的emit……场面一度很混乱orz…… 异步编程中的坑前面我们说了，异步编程很好很快很方便。然而事情总是有两面性的，异步是方便了，然而需要同步协调的时序任务就有点麻烦了。当然面对时序任务的话，完全可以不用Node平台（本来就不是它的强项）。但是人总是爱偷懒得，与其换个平台再配置一堆环境，还不如强行让Node支持时序处理，所以就有了以下解决方案。 串行任务对于串行任务，把需要串行的异步函数放进一个数组里，然后每个异步任务结束前（即回调函数触发时），调用一个调度函数进行调度。 function func0(arg){ /* Some code here */ async0(arg0, function(err, res){ if(err) next(err); next(null, res) }); } function func1(arg){ /* Some code here */ async1(arg0, function(err, res){ if(err) next(err); next(null, res) }); } /* Many tasks ... */ tasks = [ func0, func1, /* Many tasks ... */ ]; function next(err, arg){ if(err){ /* Handle error */ } var task = tasks.shift(); if(task){ task(arg); } } next(arg); 其实非要连着嵌套回调函数也可以，但是上面这种管理方法，更容易扩展和修改。 并行任务对于并行任务，把需要并行的异步函数放进一个数组里，然后每个异步任务结束前（即回调函数触发时），调用一个计数任务完成情况的函数。 function func0(){ /* Some code here */ async0(arg0, function(err, res){ if(err) { /* Handle err */ } checkFinished() }); } function func1(){ /* Some code here */ async1(arg0, function(err, res){ if(err) { /* Handle err */ } checkFinished() }); } /* Many tasks ... */ tasks = [ func0, func1, /* Many tasks ... */ ]; var tasksFinished = 0; function checkFinished(){ ++tasksFinished; if(tasksFinished == tasks.length){ //并行任务全部完成 } } function run(){ for(var task in tasks){ task(); } } run();","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Web","slug":"Web","permalink":"/tags/Web/"},{"name":"Node.js","slug":"Node-js","permalink":"/tags/Node-js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"又是新的学期","slug":"又是新的学期","date":"2017-03-03T14:33:34.000Z","updated":"2020-01-14T02:33:14.562Z","comments":true,"path":"2017/03/03/又是新的学期/","link":"","permalink":"/2017/03/03/又是新的学期/","excerpt":"一眨眼，就已经到了大三下了，马上就该毕业找工作或者考研了。 真是很神奇的一种感觉，好像大学的时间比高中快多了。隐约还记得刚来大学的第一个寒假回高中做回访，那时候高一的萌萌的小孩子们，现在也已经开始备考100天了。 很多人说，觉得时间过得快，证明生活的很充实啊。细细想来，其实也没有太充实的感觉。","text":"一眨眼，就已经到了大三下了，马上就该毕业找工作或者考研了。 真是很神奇的一种感觉，好像大学的时间比高中快多了。隐约还记得刚来大学的第一个寒假回高中做回访，那时候高一的萌萌的小孩子们，现在也已经开始备考100天了。 很多人说，觉得时间过得快，证明生活的很充实啊。细细想来，其实也没有太充实的感觉。 记得大一刚来的时候，对软件这个行业一无所知，结果不知道怎么地，在大神学长的带领下，沉迷专业不可自拔，硬生生地裸啃了《C++ Primer Plus》。现在看来，那么厚的一本书，怎么可能愿意读完嘛。去年暑假也读过《代码大全2》，完全没有心思一节一节看，到后来基本上当做手册拿去查了。 其实专业技术这个领域，我还是挺纠结的。比一般人强，但却又没有研究的特深的方向。就说今天早晨去阿里的测验做题，30分钟连个模态对话框都没写出来。唔，也怪我记性不好嘛，js里面那一堆函数，想记住随时用也真是困难。 不过毕竟算是裸考的，一点准备都没有就点进去了哈哈哈。除此之外呢，还给腾讯百度都投了一遍简历，管它呢，先去笔试面试试一下嘛。 不过这个学期以来倒是把生活作息规律了一下，至少，我居然开学到现在为止都没翘过课也是很稀罕的！当然啦，除此之外还得练字画画研究技术。嗯，还要好好锻炼一下呢！什么俯卧撑压腿，趁着邻床的室友不在，可以好好在自己床上练一下。 据说要有个好身材才能高质量的脱单呢！不然整天走在学校里，大一的大二的大三的都喵的一对一对的，真是生气生气生气！可是就算生气，还不愿意随随便便地脱单……真是人生多艰，命途多舛。 嗯，不管怎么说，新的学期，頑張って。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"/tags/随笔/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"Node.js学习笔记1","slug":"Node-js学习笔记1","date":"2017-03-03T04:33:06.000Z","updated":"2020-01-14T02:33:31.844Z","comments":true,"path":"2017/03/03/Node-js学习笔记1/","link":"","permalink":"/2017/03/03/Node-js学习笔记1/","excerpt":"《Node.js实战》的第二章给出了一个Node.js实现的ChatRoom的例子。但是……就像其他很多书上的各种例子，在我的电脑上……跑不通。 这就比较尴尬，明明有着npm的Node相对C/Java来说不太应该出现依赖缺失包缺失等问题……但是作为一个更新着的脚本语言，版本不兼容永远是个大坑。","text":"《Node.js实战》的第二章给出了一个Node.js实现的ChatRoom的例子。但是……就像其他很多书上的各种例子，在我的电脑上……跑不通。 这就比较尴尬，明明有着npm的Node相对C/Java来说不太应该出现依赖缺失包缺失等问题……但是作为一个更新着的脚本语言，版本不兼容永远是个大坑。 初始的问题抄好原书给出的服务器端的代码，然后开始运行 node server.js 得到结果 Store.prototype.__proto__ = EventEmitter.prototype; ^ TypeError: Cannot read property &#39;prototype&#39; of undefined at Object.&lt;anonymous&gt; (/home/inksmallfrog/Code/js/nodeTest/nodePro/0/node_modules/socket.io/lib/store.js:35:41) at Module._compile (module.js:571:32) at Object.Module._extensions..js (module.js:580:10) at Module.load (module.js:488:32) at tryModuleLoad (module.js:447:12) at Function.Module._load (module.js:439:3) at Module.require (module.js:498:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/home/inksmallfrog/Code/js/nodeTest/nodePro/0/node_modules/socket.io/lib/manager.js:16:13) at Module._compile (module.js:571:32) 嗯？什么鬼，Google之，得到解释是书上例子用的Socket.IO的版本是~0.9.6，这个版本不能在node 7.x的版本上运行…… 好吧，那既然这样不行，我就试试最新版本的Socket.IO吧。于是在packat.json中做如下修改 &quot;socket.io&quot;: &quot;~0.9.6&quot;, =&gt; &quot;socket.io&quot;: &quot;latest&quot;, 然后 npm install OK, 获得了1.7.3的Socket.io版本。 新版本的灾难运行服务器正常，然后打开网页的时候 if (fn) process.nextTick(fn.bind(null, null, sids)); ^ TypeError: fn.bind is not a function at Adapter.clients (/home/inksmallfrog/Code/js/nodeTest/nodePro/0/node_modules/socket.io-adapter/index.js:196:31) at Namespace.clients (/home/inksmallfrog/Code/js/nodeTest/nodePro/0/node_modules/socket.io/lib/namespace.js:256:16) at joinRoom (/home/inksmallfrog/Code/js/nodeTest/nodePro/0/lib/chat_server.js:61:34) at Namespace.&lt;anonymous&gt; (/home/inksmallfrog/Code/js/nodeTest/nodePro/0/lib/chat_server.js:21:9) at emitOne (events.js:96:13) at Namespace.emit (events.js:189:7) at Namespace.emit (/home/inksmallfrog/Code/js/nodeTest/nodePro/0/node_modules/socket.io/lib/namespace.js:209:10) at /home/inksmallfrog/Code/js/nodeTest/nodePro/0/node_modules/socket.io/lib/namespace.js:177:14 at _combinedTickCallback (internal/process/next_tick.js:67:7) at process._tickCallback (internal/process/next_tick.js:98:9) 哈?这又是什么鬼？再次Google之。得到的答案是Socket.IO新版本的调用方式改变了。心累。怎么办呢，去官网查一下文档凑合着改改吧……Socket.IO 然而，这个官网的服务器好像是……挂了？我服…… 幸好我们还有StackOverflow和Github Issue这种东西 参考这个Socket.IO issue#2428改掉代码。 socket.emit(&#39;rooms&#39;, io.sockets.manager.rooms); =&gt; socket.emit(&#39;rooms&#39;, io.of(&#39;/&#39;).adapter.rooms); var usersInRoom = io.sockets.clients(room); =&gt; var usersInRoom = io.of(&#39;/&#39;).in(room).clients; OK，可以正常运行了。 房间列表中的随机字符串然而运行是没问题了，可是房间列表和房间用户根本就不显示啊！那就让它输出一下看看这个io.of(‘/‘).adapter.rooms看看到底是获得了什么东西。 { oInACthwnqMzY7KBAAAA: Room { sockets: { oInACthwnqMzY7KBAAAA: true }, length: 1 }, Lobby: Room { sockets: { oInACthwnqMzY7KBAAAA: true }, length: 1 } } 我们看到了默认的房间名Lobby,这个没问题。可上面那个随机字符串是什么鬼？不想动脑子了，直接stackoverflow找到了一个不错的解决方法。正准备直接搬运过来。 嗯？等等，sockets，这里的内容应该放的是房间里的用户的socket吧？那这么说来Socket.IO的新版本会给每个用户的SocketId也创建一个独立的房间咯？噗……可怕的随机字符串。 那想到这里，房间列表和房间里面的用户都可以解决了。将对应代码做如下替换 //服务器端 chat_server.js socket.on(&#39;rooms&#39;, function(){ var rooms = []; var rooms_and_sockets = io.sockets.adapter.rooms; if(rs){ for(var room_or_socket in rooms_and_sockets){ if(!rooms_and_sockets[room_or_socket].sockets.hasOwnProperty(room_or_socket)){ rooms.push(room_or_socket); } } } socket.emit(&#39;rooms&#39;, rooms); }); var usersInRoom = io.sockets.adapter.rooms[room]; if (usersInRoom.length &gt; 1){ var usersInRoomSummary = &#39;Users currently in &#39; + room + &#39;: &#39;; var i = 0; for(var socketId in usersInRoom.sockets){ if(socketId != socket.id){ if(i &gt; 0){ usersInRoomSummary += &#39;, &#39;; } usersInRoomSummary += nickNames[socketId]; ++i; } } usersInRoomSummary += &#39;.&#39;; socket.emit(&#39;message&#39;, {text: usersInRoomSummary}); } 由于房间列表原来的Json对象格式替换为了数组格式客户端做如下修改 //chat_ui.js socket.on(&#39;rooms&#39;, function(rooms){ $(&#39;#room-list&#39;).empty(); for(var i in rooms){ if(rooms[i] != &#39;&#39;){ $(&#39;#room-list&#39;).append(divEscapedContentElement(rooms[i])); } } $(&#39;#room-list div&#39;).click(function(){ chatApp.processCommand(&#39;/join &#39; + $(this).text()); $(&#39;#send-message&#39;).focus(); }); }) OK,just run it.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Web","slug":"Web","permalink":"/tags/Web/"},{"name":"Node.js","slug":"Node-js","permalink":"/tags/Node-js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Node.js学习笔记0","slug":"Node.js学习笔记0","date":"2017-03-02T13:37:37.000Z","updated":"2020-01-14T02:33:38.364Z","comments":true,"path":"2017/03/02/Node.js学习笔记0/","link":"","permalink":"/2017/03/02/Node.js学习笔记0/","excerpt":"春天又要来了，每年春天呢，都是学习新技术的好时候。嗯，虽然这次计划要学的不算是什么很新的技术，但是在这个Web流行的时代大概还是有些用处的吧。 Node.js这个玩意儿呢，之前就接触过一些，Express框架也用过一点，但总归是只知道些皮毛而已，所以乘着这段时间的心血来潮，补补这本《Node.js实战》","text":"春天又要来了，每年春天呢，都是学习新技术的好时候。嗯，虽然这次计划要学的不算是什么很新的技术，但是在这个Web流行的时代大概还是有些用处的吧。 Node.js这个玩意儿呢，之前就接触过一些，Express框架也用过一点，但总归是只知道些皮毛而已，所以乘着这段时间的心血来潮，补补这本《Node.js实战》 为什么有了它（致那段“崎岖”的Web发展史） 很久很久以前，一群很厉害的人为了方便信息发布在Internet的基础上制订了HTTP协议 很久以前，Web技术快速发展，Ajax技术成熟，以前单纯为了分享信息的网站变的复杂 多数网站开始使用实时的动态的交互方式，并发性增强 传统的服务器（比如Apache）采用阻塞式I/O模型，因此为了保证多个客户端访问的实时性，必须为每个连接建立单独的线程/进程 网站并发性越来越强，线程/进程开多了，CPU来回切换就会很累，而且内存记录信息也很累。 那干脆就不要搞阻塞式I/O了呗！学学浏览器的设计，改成异步I/O事件轮询吧！等等，学浏览器？那不妨基于JavaScript吧！ 它是什么鬼官网定义： 一个搭建在Chrome JavaScript运行时上的平台,用于构建高速、可伸缩的网络程序。Node.js采用的事件驱动、非阻塞I/O模型,使它既轻量又高效,并成为构建运行在分布式设备上的数据密集型实时程序的完美选择要点： JavaScript运行时上的平台 构建网络程序 Non blocking I/O DIRT(data-intensive real-time)Node.js所针对的应用程序的简称，设计目的是为了保证响应能力。 最后总结，Node.js就是为网络中数据密集型实时程序设计的非阻塞式I/O，数据驱动的，JavaScript平台","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Web","slug":"Web","permalink":"/tags/Web/"},{"name":"Node.js","slug":"Node-js","permalink":"/tags/Node-js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"REST&RESTful笔记","slug":"REST-RESTful笔记","date":"2017-02-26T03:58:59.000Z","updated":"2020-01-14T02:33:41.844Z","comments":true,"path":"2017/02/26/REST-RESTful笔记/","link":"","permalink":"/2017/02/26/REST-RESTful笔记/","excerpt":"RESTREST(Representational State Transfer)，由Roy Thomas Fielding在2000年的博士论文中提出，是一种互联网软件的架构原则。 ResourcesRepresentational的主语为资源，资源是网络上的一个实体。每一个网络上的资源都有一个URI(Uniform Resource Identify)标识。获取资源的过程就是调用其URI。","text":"RESTREST(Representational State Transfer)，由Roy Thomas Fielding在2000年的博士论文中提出，是一种互联网软件的架构原则。 ResourcesRepresentational的主语为资源，资源是网络上的一个实体。每一个网络上的资源都有一个URI(Uniform Resource Identify)标识。获取资源的过程就是调用其URI。 Representation资源的载体，即其具体呈现的形式。URI只代表资源实体，不代表其形式。资源表现形式应在HTTP请求中用Accept和Content-Type字段指定。 State Transfer客户端想操作服务器，必须通过某种方式，让服务器在表现层上进行“状态转化”。客户端的手端只能是HTTP协议： GET POST PUT DELETE RESTful架构符合REST原则的架构风格 每一个URI代表一种资源 客户端和服务器之间，传递这种资源的某种表现层 客户端通过四个HTTP动词，实现服务器上的“表现层状态转化”","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Web","slug":"Web","permalink":"/tags/Web/"},{"name":"REST","slug":"REST","permalink":"/tags/REST/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"WebService基础学习","slug":"WebService基础学习","date":"2017-02-26T03:56:36.000Z","updated":"2020-01-14T02:34:46.719Z","comments":true,"path":"2017/02/26/WebService基础学习/","link":"","permalink":"/2017/02/26/WebService基础学习/","excerpt":"鉴于这次的软件体系结构要交一份WebService的作业，所以顺路记一些学习笔记。 从WebService说起很久很久很久以前，世界上是没有电脑的。很久很久以前，两台电脑之间是不能通讯的。很久以前，出现了Web，它连接起了不同硬件，不同平台的计算机。于是，人们就开始希望两台计算机之间的应用程序，能够互相通讯，就有了WebService","text":"鉴于这次的软件体系结构要交一份WebService的作业，所以顺路记一些学习笔记。 从WebService说起很久很久很久以前，世界上是没有电脑的。很久很久以前，两台电脑之间是不能通讯的。很久以前，出现了Web，它连接起了不同硬件，不同平台的计算机。于是，人们就开始希望两台计算机之间的应用程序，能够互相通讯，就有了WebService WebService,最简单的就是理解成一个互联网上的API接口。类比互联网上常规的浏览网页的方式：你发来一个http规定的文档，我返回一种http规定的文档。最后浏览器根据http协定，将获得的内容解析并呈现。而WebService则于此相似：你发来一个带有协定好的参数的一定格式的消息，我返回去一个带有协定好的返回值的一定格式的消息。最后你根据文档的格式，把返回值解析出来就好。那么这里的问题是： 消息的格式是什么，怎么跨平台传输？ 怎么协定参数和返回值？解决方案： 因为这个请求是基于Web，所以首先想到了http。 但是http只是两个设备间的一个交通工具，它不能负责识别各类复杂的数据。所以呢，我们就需要约定一套新的数据访问协议，专门用来识别数据并且将它们包装或拆包。这样子就能把数据格式从设备平台上独立出来了。而最为常用的数据访问协议，就是SOAP（简单对象访问协议），它是基于XML实现的数据访问。 共同约定一个文档格式呗。 为了同时便于机器解析和人类阅读，比较常用的格式就是WSDL文档了。这是一个基于XML的文档，至于里面标记的含义老师讲过一点但我没听，用的时候自行理解或者百歌就好。 WebService服务流程 用户发现了这个WebService服务 用户阅读（或用工具解析后理解）它的WSDL文档 用户将准备好的SOAP消息（带有需要参数的XML文档）发到服务器 服务器解析SOAP消息后进行处理 服务器产生SOAP消息（带有需求返回值的XML文档）并返回给用户 用户收到SOAP消息并解析获取返回结果 测试WebService的服务测试WebService的方法应该挺多的，但我这里偷下懒，就只用我们老师要求使用的SOAPUI了。 打开SOAPUI 点击工具栏中的SOAP，添加SOAP工程Initial。 WSDL一栏，填写本地的或Web上的WSDL地址。这里我用了一个免费的中英互译WebService测试：地址为http://www.webxml.com.cn/WebServices/TranslatorWebService.asmx?WSDL 找到我们要测试的服务( 那个HelloWebXml,只是个用来做测试的东西，无视掉就好) SOAPUI已经帮忙生成好了SOAP消息框架，只需要自己填参数 点击运行按钮进行测基础的功能就是这些，我暂时用到这里就足够了，至于其它的应用，若有需要自行谷歌…… 几个免费的WebService服务 中国股票行情分时走势预览缩略图 WEB 服务 中国股票行情数据 WEB 服务 中文英文双向翻译 WEB 服务 中文简体字繁体字转换 WEB 服务 Email地址验证 WEB 服务 验证码图片 WEB 服务 天气预报 Web 服务","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Web","slug":"Web","permalink":"/tags/Web/"},{"name":"WebService","slug":"WebService","permalink":"/tags/WebService/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"webOptimization","slug":"webOptimization","date":"2017-02-26T03:06:33.000Z","updated":"2020-01-14T02:33:55.753Z","comments":true,"path":"2017/02/26/webOptimization/","link":"","permalink":"/2017/02/26/webOptimization/","excerpt":"压缩源码和图片选择合适的图片格式合并静态资源减少HTTP请求 CSS放在头部，Js放在尾部延迟加载Js（其实也可以放在头部，利用defer=”defer”属性标识延迟，这样子可读性和可维护性更高） 使用CDN增加并发下载量，和其它网站共享缓存","text":"压缩源码和图片选择合适的图片格式合并静态资源减少HTTP请求 CSS放在头部，Js放在尾部延迟加载Js（其实也可以放在头部，利用defer=”defer”属性标识延迟，这样子可读性和可维护性更高） 使用CDN增加并发下载量，和其它网站共享缓存 开启服务器端的Gzip压缩利用缓存服务器缓存 利用数据库自带缓存 利用服务器集群实现数据库缓存——memcached 利用文件缓存 页面静态化浏览器缓存 设置Expires` 设置Last-Modified 设置Cache-Control 意外情况：缓存被挤出，文件被运营商服务器劫持。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Web","slug":"Web","permalink":"/tags/Web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"ubuntu下NTFS分区挂载失败解决","slug":"ubuntu下NTFS分区挂载失败解决","date":"2017-02-26T01:04:39.000Z","updated":"2020-01-14T02:33:46.167Z","comments":true,"path":"2017/02/26/ubuntu下NTFS分区挂载失败解决/","link":"","permalink":"/2017/02/26/ubuntu下NTFS分区挂载失败解决/","excerpt":"问题最近一段时间用Linux挂载Windows下的NTFS分区的时候，老是报这个错误而且最讨厌的还是时好时不好的 今天忍受不了了，Google到了一个解决方案 sudo ntfsfix &lt;dev-name&gt; 直接把报错的分区修复了","text":"问题最近一段时间用Linux挂载Windows下的NTFS分区的时候，老是报这个错误而且最讨厌的还是时好时不好的 今天忍受不了了，Google到了一个解决方案 sudo ntfsfix &lt;dev-name&gt; 直接把报错的分区修复了 原因顺带查了一下原因，ArchLinux的Wiki上面描述如下： 当与Windows 8 或 10双引导时,试图挂载一个可见的Windows可能会出现如下错误: The disk contains an unclean file system (0, 0).Metadata kept in Windows cache, refused to mount.Failed to mount ‘/dev/sdc1’: Operation not permittedThe NTFS partition is in an unsafe state. Please resume and shutdownWindows fully (no hibernation or fast restarting), or mount the volumeread-only with the ‘ro’ mount option.)) 问题是因为Windows 8中引入”快速启动”特性。启用快速启动后，所有分区的元数据的一部分被还原到它们在以前关闭的状态。因此，在 Linux 上所做的更改可能会丢失。这会发生在任何选择”关闭”或”休眠” NTFS 分区的Windows 8 或 10 下。然而，通过选择”重新启动”，离开 Windows 是看似安全的。要启用对其他操作系统的系统分区写入，请确保禁用快速重启。要做到这一点通过以管理员身份执行命令: powercfg /h off","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}